NULL
}
t2 <- Sys.time()
return(t2 - t1)
}
### Here starts the timing experiments
## Warm up the CPU. Results will NOT be recorded.
for(i in 1:5){
simulation_timing()
}
## begin the real experiments
df_timing_results <- c()
all_n <- c(8, 16, 24)##c(8, 40, 200, 1000)
all_tmax <- c(50, 100, 200)##c(100, 500, 1000)
all_nrun <- c(10, 20, 30)##c(10, 100, 1000)
for(n in all_n){
for(tmax in all_tmax){
for(nrun in all_nrun){
runtime <- simulation_timing(n = n, tmax = tmax, nrun = nrun)
runtime <- as.numeric(runtime, units = "secs")
df_timing_results <- data.frame(
rbind(data.frame(df_timing_results),
data.frame(n = n, tmax = tmax, nrun = nrun, runtime = runtime)))
}
}
}
## Visualize the runtime results
knitr::kable(df_timing_results, caption = "")
plot(NULL, main = "Runtime vs n * tmax with nrun fixed", xlab = "n * tmax",
ylab = "runtime", xlim = c(min(all_n) * min(all_tmax),
max(all_n) * max(all_tmax)),
ylim = c(0, max(df_timing_results$runtime)))
colors = distinctColorPalette(length(all_nrun))
for (i in 1:length(all_nrun)) {
dat <- df_timing_results[df_timing_results$nrun == all_nrun[i],]
lines(dat$n * dat$tmax, dat$runtime, lwd = 2, col = colors[i])
}
legend("topleft", paste("nrun =", all_nrun), col = colors,
bg = "gray", cex = 0.6, lwd = 3)
order(c(2,3,4,1))
sorted(c(2,3,4,1))
sort(c(2,3,4,1))
df_timing_results
simulation_timing <- function(n = 8, tmax = 1e2, nrun = 1e1){
###
# simulation_time() allows you to adjust the number of each factor
# that may impact the scalability of the simulation, and return
# the runtime of the simulation. Notice that the runtime is not recorded
# for the processes that setup the parameters. The runtime is only recorded
# for the period of simulations.
#
# Inputs:
#   n: number of patches. DEFAULT = 8.
#   tmax: maximum time step for the simulation. DEFAULT = 100.
#   nrun: number of trials to simulate. DEFAULT = 10.
#
# Outputs:
#   runtime of the simulation.
#
# Notice:
#   the number of people in each patch is turned down from 1000 to 100
#   in order to save time.
###
path <- here("data/output/")
if(!dir.exists(path)){
dir.create(path)
} else {
files <- list.files(path)
if(length(files) > 0){
for(f in files){
file.remove(paste0(path,f))
}
}
}
# vector of parameters
pfsi_pars <- pfsi_parameters()
#### set up patches (n is how many patches we have)
###n <- 200
# movement matrix for humans is uniform over possible destinations.
move <- matrix(data = 1/(n-1),nrow = n,ncol = n)
diag(move) <- 0
patch_pars <- patches_parameters(move = move,bWeightZoo = rep(0,n),bWeightZootox = rep(0,n),reservoir = rep(F,n),res_EIR = rep(0,n))
# mosquitos
psi <- Matrix::sparseMatrix(i = {},j = {},x = 0.0,dims = c(n,n))
diag(psi) <- rep(1,n)
mosy_pars <- mosquito_rm_conpars(N = n,lambda = matrix(50,nrow = 365,ncol = n),
psi = psi,EIP = rep(11,365),M = rep(450,n),Y = rep(0,n),Z = rep(0,n))
# humans
patch_sizes <- rep(1e2,n) # number of people in each patch
pfpr <- rep(0.5,n) # malaria prevalence in each patch
nh <- sum(patch_sizes) # total num of humans
# sample S or I for each person
init_state <- unlist(mapply(FUN = function(n,pr){
sample(x = c("I","S"),size = n,replace = T,prob = c(pr,1-pr))
},n=patch_sizes,pr=pfpr,SIMPLIFY = F))
# where the people go (0-indexed for c++)
patch_id <- rep(0:(n-1),times=patch_sizes)
# uniform biting weights; this could follow any density on the positive reals (gamma, log-normal, weibull, etc.)
bweights <- rep(1,nh)
# the data structure that will be passed down to C++ to construct the human pop
human_pars <- vector("list",nh)
for(i in 1:nh){
human_pars[[i]] <- human_pfsi_conpars(id = i-1,home_patch_id = patch_id[i],
trip_duration = rep(3,n),trip_frequency = 1/20,bweight = bweights[i],
age = 20,state = init_state[i],bite_algorithm = 0)
}
# vaccinations (can uncomment the code below to vaccinate 25% of the population at day 500)
# vaxx_pars <- list()
vaxx_id <- sample(x = 0:(nh-1),size = nh*0.25,replace = F)
vaxx_pars <- lapply(X = vaxx_id,FUN = function(id){
vaccination_pfsi_conpars(id = id,t = 5e2,treat = T,type = "PE")
})
log_pars <- list()
h_inf <- paste0(path,"pfsi.csv")
log_pars[[1]] <- list(outfile = h_inf,key = "pfsi",
header = paste0(c("time","patch",unlist(lapply(c("S","I","P"),function(x){paste0(x,c("_visitor","_resident_home","_resident_away"))})),"incidence_resident","incidence_traveller"),collapse = ",")
)
mosy <- paste0(path,"mosy.csv")
log_pars[[2]] <- list(outfile = mosy,key = "mosquito",
header = paste0(c("time","state",paste0("patch",1:n)),collapse = ","))
### Run Patches
###nrun <- 1e2
tsteps <- tmax
pb <- txtProgressBar(min = 1,max = nrun)
t1 <- Sys.time()
var_foreach <- foreach(i = 1:nrun, .packages = "macro.pfsi") %dopar% {
log_pars <- list()
h_inf <- paste0(path,"pfsi_",i,".csv")
log_pars[[1]] <- list(outfile = h_inf,key = "pfsi",
header = paste0(c("time","patch",unlist(lapply(c("S","I","P"),function(x){paste0(x,c("_visitor","_resident_home","_resident_away"))})),"incidence_resident","incidence_traveller"),collapse = ","))
mosy <- paste0(path,"mosy_",i,".csv")
log_pars[[2]] <- list(outfile = mosy,key = "mosquito",
header = paste0(c("time","state",paste0("patch",1:n)),collapse = ","))
run_macro(tmax = tsteps,
human_pars = human_pars,
mosquito_pars = mosy_pars,
patch_pars = patch_pars,
model_pars = pfsi_pars,
log_streams = log_pars,
vaxx_events = vaxx_pars,
verbose = FALSE)
setTxtProgressBar(pb,i)
NULL
}
t2 <- Sys.time()
return(t2 - t1)
}
### Here starts the timing experiments
## Warm up the CPU. Results will NOT be recorded.
for(i in 1:5){
simulation_timing()
}
## begin the real experiments
df_timing_results <- c()
all_n <- c(8, 16, 24)##c(8, 40, 200, 1000)
all_tmax <- c(50, 100, 200)##c(100, 500, 1000)
all_nrun <- c(10, 20, 30)##c(10, 100, 1000)
for(n in all_n){
for(tmax in all_tmax){
for(nrun in all_nrun){
runtime <- simulation_timing(n = n, tmax = tmax, nrun = nrun)
runtime <- as.numeric(runtime, units = "secs")
df_timing_results <- data.frame(
rbind(data.frame(df_timing_results),
data.frame(n = n, tmax = tmax, nrun = nrun, runtime = runtime)))
}
}
}
## Visualize the runtime results
knitr::kable(df_timing_results, caption = "")
plot(NULL, main = "Runtime vs n * tmax with nrun fixed", xlab = "n * tmax",
ylab = "runtime", xlim = c(min(all_n) * min(all_tmax),
max(all_n) * max(all_tmax)),
ylim = c(0, max(df_timing_results$runtime)))
colors = distinctColorPalette(length(all_nrun))
for (i in 1:length(all_nrun)) {
dat <- df_timing_results[df_timing_results$nrun == all_nrun[i],]
dat <- dat[order(dat$n * dat$tmax),]
lines(dat$n * dat$tmax, dat$runtime, lwd = 2, col = colors[i])
}
legend("topleft", paste("nrun =", all_nrun), col = colors,
bg = "gray", cex = 0.6, lwd = 3)
matrix(NA, nrow = 3, ncol = 0)
pfsi
here("data/output")
here("data/output/")
m <- matrix(1:12, nrow = 3)
m
m <- matrix(1:12, nrow = 3, byrow = T)
m
matrix(m, nrow = 1)
matrix(m, nrow = 1, byrow = T)
matrix(m, nrow = 1, byrow = F)
list.files(path = here("data/output/"),pattern = "pfsi_[[:digit:]]+.csv")
?list.files
list.files(path = here("data/output/"),pattern = "pfsi_[[1:digit:5]]+.csv")
list.files(path = here("data/output/"),pattern = "pfsi_[[:digit:]]0?.csv")
list.files(path = here("data/output/"),pattern = "pfsi_3.csv")
paste0("pfsi_", 1:5, ".csv")
all_nrun
length(colors)
time_msd <- function(nrun = 10){
t1 <- Sys.time()
df_curr <- fread(here("data/output/pfsi_1.csv"), sep = ",", header = T)
mat_curr <- as.matrix(df_curr)
mat_mean <- mat_curr[, 3:ncol(mat_curr)]
mat_sq <- mat_curr**2
for(i in 2:nrun){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
mat_curr <- as.matrix(df_curr)
df_curr <- data.frame(df_curr)
mat_curr <- mat_curr[, 3:ncol(mat_curr)]
mat_mean <- mat_mean + mat_curr
mat_sq <- mat_sq + mat_curr**2
}
mat_mean <- mat_mean / nrun
mat_sd <- sqrt(mat_sq / nrun - mat_mean**2)
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_forloop <- function(nrun = 10){
t1 <- Sys.time()
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melted_df2 <- melt(df_curr, id.vars = c("time", "patch"))
for(i in 2:nrun){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melt_curr <- melt(df_curr, id.vars = c("time", "patch"))
melted_df2 <- cbind(melted_df2, melt_curr$value)
}
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_lapply <- function(nrun = 10){
melted_df2 <- melt(pfsi, id.vars = c("time", "patch"))
melted_df2 <- melted_df2[, !names(melted_df2) %in% c("value")]
t1 <- Sys.time()
flist <- paste0("pfsi_", 1:nrun, ".csv")
df_tmp <- do.call(cbind, lapply(paste0("output/", flist), function(x){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melt_curr <- melt(df_curr, id.vars = c("time", "patch"))
melt_curr$value
}))
melted_df2 <- cbind(melted_df2, data.frame(df_tmp))
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_tidyverse <- function(nrun = 10){
t1 <- Sys.time()
pfsi_combined <-
paste0("pfsi_", 1:nrun, ".csv") %>%
map(~read_csv(paste0(here("data/output/"),.)) %>%
gather(Key, Value, -time, -patch)) %>%
reduce(full_join, by = c("time", "patch", "Key"))
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
## Warm Up CPUs
for(i in 1:5){
time_msd()
}
mat_sq
time_msd <- function(nrun = 10){
t1 <- Sys.time()
df_curr <- fread(here("data/output/pfsi_1.csv"), sep = ",", header = T)
mat_curr <- as.matrix(df_curr)
mat_mean <- mat_curr[, 3:ncol(mat_curr)]
mat_sq <- mat_curr**2
print(dim(mat_mean))
print(dim(mat_sq))
for(i in 2:nrun){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
mat_curr <- as.matrix(df_curr)
df_curr <- data.frame(df_curr)
mat_curr <- mat_curr[, 3:ncol(mat_curr)]
mat_mean <- mat_mean + mat_curr
mat_sq <- mat_sq + mat_curr**2
}
mat_mean <- mat_mean / nrun
mat_sd <- sqrt(mat_sq / nrun - mat_mean**2)
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_forloop <- function(nrun = 10){
t1 <- Sys.time()
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melted_df2 <- melt(df_curr, id.vars = c("time", "patch"))
for(i in 2:nrun){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melt_curr <- melt(df_curr, id.vars = c("time", "patch"))
melted_df2 <- cbind(melted_df2, melt_curr$value)
}
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_lapply <- function(nrun = 10){
melted_df2 <- melt(pfsi, id.vars = c("time", "patch"))
melted_df2 <- melted_df2[, !names(melted_df2) %in% c("value")]
t1 <- Sys.time()
flist <- paste0("pfsi_", 1:nrun, ".csv")
df_tmp <- do.call(cbind, lapply(paste0("output/", flist), function(x){
df_curr <- fread(paste(here("data/output/"), "pfsi_", i, ".csv", sep = ""),
sep = ",", header = T)
df_curr <- data.frame(df_curr)
melt_curr <- melt(df_curr, id.vars = c("time", "patch"))
melt_curr$value
}))
melted_df2 <- cbind(melted_df2, data.frame(df_tmp))
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
time_tidyverse <- function(nrun = 10){
t1 <- Sys.time()
pfsi_combined <-
paste0("pfsi_", 1:nrun, ".csv") %>%
map(~read_csv(paste0(here("data/output/"),.)) %>%
gather(Key, Value, -time, -patch)) %>%
reduce(full_join, by = c("time", "patch", "Key"))
t2 <- Sys.time()
return(as.numeric(t2 - t1, units = "secs"))
}
## Warm Up CPUs
for(i in 1:5){
time_msd()
}
library(reportfactory)
list_reports()
compile_report("pfsi_sim_tools_2019-09-06.Rmd", quiet = T)
colorPalette
?write.csv
?foreach
object.size(pfsi)
object.size(melted_df2)
nrow(pfsi)
object.size(pfsi) * 5 * 1000
as.numeric(object.size(pfsi) * 5 * 1000, units = "gb")
as.numeric(object.size(pfsi) * 5 * 1000, units = "GB")
format(object.size(pfsi) * 5 * 1000, units = "GB")
30/log10(2)
log10(2)
?list
?run_macro
?setTxtProgressBar
setwd("~/Desktop/others/IHME/Macro/TravelingModel/traveling_fit")
rel_gravity_dat_covs <- read.csv("rel_gravity_dat_covs.csv")
head(rel_gravity_dat_covs)
class(rel_gravity_dat_covs)
BI_survey_data <- read.csv("BI_survey_data.csv")
n_sample <- data.frame(BI_survey_data[, c("areaId", "n")])
rel_gravity_dat_covs <- merge(rel_gravity_dat_covs, n_sample, by = "areaId")
head(rel_gravity_dat_covs)
source("extract_models.R")
?reformulate
?offset
source("extract_models.R")
super_model_fits(rel_gravity_dat_covs, "poisson", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
rel_gravity_dat_covs[rel_gravity_dat_covs$w==0,]
rel_gravity_dat_covs[rel_gravity_dat_covs$N1==0,]
rel_gravity_dat_covs[rel_gravity_dat_covs$N2==0,]
rel_gravity_dat_covs[rel_gravity_dat_covs$d==0,]
rel_gravity_dat_covs[rel_gravity_dat_covs$n==0,]
super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"poisson", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
head(rel_gravity_dat_covs)
nrow(rel_gravity_dat_covs[rel_gravity_dat_covs$n == 0,])
nrow(BI_survey_data[BI_survey_data$n == 0,])
nrow(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,])
source("extract_models.R")
super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"poisson", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
source("extract_models.R")
super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"negbin", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
smf <- super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"negbin", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
sum((smf$model_far$fitted.values - smf$true_value_far)^2)+sum((smf$model_near$fitted.values - smf$true_value_near)^2)
colnames(rel_gravity_dat_covs)
"n" %in% colnames(rel_gravity_dat_covs)
"n2" %in% colnames(rel_gravity_dat_covs)
source("extract_models.R")
smf_offset <- super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"negbin", image_name = "offset",
cutoff = 20 * 1000, use_time = F)
smf_nooffset <- super_model_fits(rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
"negbin", image_name = "no_offset",
cutoff = 20 * 1000, use_time = F, offset = F)
sum((smf_offset$model_far$fitted.values - smf_offset$true_value_far)^2) +
sum((smf_offset$model_near$fitted.values - smf_offset$true_value_near)^2)
sum((smf_nooffset$model_far$fitted.values - smf_nooffset$true_value_far)^2) +
sum((smf_nooffset$model_near$fitted.values - smf_nooffset$true_value_near)^2)
pred_offset <- predict(smf_offset, rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
type = "response")
pred_nooffset <- predict(smf_nooffset, rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
type = "response")
get_total_w <- function(smf, rel_dat, cutoff){
dat_far <- rel_dat[rel_dat$d > cutoff,]
dat_near <- rel_dat[rel_dat$d <= cutoff,]
pred_far <- dat_far$N1 / dat_far$n * smf$model_far$fitted.values
pred_near <- dat_near$N1 / dat_near$n * smf$model_near$fitted.values
true_far <- dat_far$N1 / dat_far$n * smf$true_value_far
true_near <- dat_near$N1 / dat_near$n * smf$true_value_near
return(list(true_values = c(true_far, true_near),
pred_values = c(pred_far, pred_near)))
}
res_offset <- get_total_w(smf_offset, rel_gravity_dat_covs, 20 * 1000)
res_nooffset <- get_total_w(smf_nooffset, rel_gravity_dat_covs, 20 * 1000)
length(smf$true_value_far)
nrow(rel_gravity_dat_covs[rel_gravity_dat_covs$d > 20000,])
res_offset <- get_total_w(smf_offset,
rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
20 * 1000)
res_nooffset <- get_total_w(smf_nooffset,
rel_gravity_dat_covs[rel_gravity_dat_covs$n > 0,],
20 * 1000)
sum((res_offset$true_values - res_offset$pred_values)^2)
sum((res_nooffset$true_values - res_nooffset$pred_values)^2)
install.packages("plot3D")
library(plot3D)
lines3D(df_timing_results$n, df_timing_results$tmax, df_timing_results$runtime)
lines3D(df_timing_results$n, df_timing_results$tmax, df_timing_results$runtime, colvar = df_timing_results$nrun)
df_timing_results$nrun
points3D(df_timing_results$n, df_timing_results$tmax, df_timing_results$runtime, colvar = df_timing_results$nrun)
points3D(df_timing_results$n, df_timing_results$tmax, df_timing_results$runtime, colvar = df_timing_results$nrun, pch=19)
install.packages("plotly")
library(plotly)
plot_ly(data = df_timing_results, z = ~runtime) %>% add_surface()
head(volcano)
nrow(volcano)
ncol(volcano)
?plot_ly
plot_ly(data = df_timing_results, split = nrun) %>% add_surface()
plot_ly(data = df_timing_results, split = nrun, z = runtime) %>% add_surface()
plot_ly(data = df_timing_results, split = nrun, z = ~runtime) %>% add_surface()
head(economics)
plot_ly(data = df_timing_results, split = ~nrun, x = ~n, y = ~tmax) %>% add_surface()
plot_ly(data = df_timing_results, split = ~nrun, x = ~n, y = ~tmax)
plot_ly(data = df_timing_results, split = ~nrun, x = ~n, y = ~tmax, z = ~runtime)
plot_ly(data = df_timing_results, split = ~nrun, x = ~n, y = ~tmax, z = ~runtime) %>% add_trace()
plot_ly(data = df_timing_results, split = ~nrun, x = ~n, y = ~tmax, z = ~runtime) %>% add_trace(type = "mesh3d")
knitr::opts_chunk$set(echo = TRUE)
# 3D plot
plot_ly(data = df_timing_results, x = ~n, y = ~tmax, z = ~runtime) %>% add_trace(type = "mesh3d")
plot_ly(data = df_timing_results, x = ~n, y = ~tmax, z = ~runtime) %>%
add_trace(type = "mesh3d")
plot_ly(data = df_timing_results, x = ~n, y = ~tmax, z = ~runtime, split = ~nrun) %>%
add_trace(type = "mesh3d")
p <- plot_ly()
for (i in 1:length(all_nrun)) {
dat <- df_timing_results[df_timing_results$nrun == all_nrun[i],]
p <- p + add_trace(data = dat, x = ~n, y = ~tmax, z = ~runtime, type = "mesh3d")
}
p
p <- plot_ly()
for (i in 1:length(all_nrun)) {
dat <- df_timing_results[df_timing_results$nrun == all_nrun[i],]
p <- p %>% add_trace(data = dat, x = ~n, y = ~tmax, z = ~runtime, type = "mesh3d")
}
p
?add_trace
plot_ly(data = df_timing_results, x = ~n, y = ~tmax, z = ~runtime, split = ~nrun) %>%
add_trace(type = "mesh3d", col = "red")
p <- plot_ly()
for (i in 1:length(all_nrun)) {
dat <- df_timing_results[df_timing_results$nrun == all_nrun[i],]
p <- p %>% add_trace(data = dat, x = ~n, y = ~tmax, z = ~runtime, type = "mesh3d",
name = paste("nrun =", all_nrun[i]))
}
p
object.size(pfsi)
nrow(pfsi)
object.size(melted_df2)
nrow(melted_df2)
ncol(pfsi)
idv <- object.size(pfsi)
aggr <- object.size(melted_df2)
idv * 225/200 * 1.5 * 10
ncol(melted_df2)
aggr * 225/200 * 1.5 * 10
225 * 1500
ncol(pfsi)
aggr * 225/200 * 1.5 * 10
format(aggr * 225/200 * 1.5 * 10, unit = "GB")
setwd("~/Desktop/others/IHME/Macro/TravelingModel/traveling_fit")
setwd("~/Desktop/others/IHME/Macro/TravelingModel/traveling_fit/my_reports/")
library(reportfactory)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
compile_report("pfsi_sim_tools_2019-09-11.Rmd", quiet = T)
setwd("~/Desktop/others/IHME/Macro/TravelingModel/traveling_fit")
source("extract_models.R")
rel_gravity_dat_covs <- read.csv("rel_gravity_dat_covs.csv")
BI_survey_data <- read.csv("BI_survey_data.csv")
n_sample <- data.frame(BI_survey_data[, c("areaId", "n")])
